// -------------------------------------------------------
// Advent of Code 2023 - Day 7
// -------------------------------------------------------

use std::{cmp::Ordering, collections::HashMap};

use crate::read_input;

// -------------------------------------------------------
// Global Variables
// -------------------------------------------------------

// const CARDS: [char; 13] = [
//     '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A',
// ];

// -------------------------------------------------------
// Custom Data Structures
// -------------------------------------------------------

#[derive(Debug, PartialEq, PartialOrd)]
enum Card {
    Ace,
    King,
    Queen,
    Jack,
    Ten,
    Nine,
    Eight,
    Seven,
    Six,
    Five,
    Four,
    Three,
    Two,
}

impl Card {
    fn from(card: char) -> Self {
        match card {
            'A' => Self::Ace,
            'K' => Self::King,
            'Q' => Self::Queen,
            'J' => Self::Jack,
            'T' => Self::Ten,
            '9' => Self::Nine,
            '8' => Self::Eight,
            '7' => Self::Seven,
            '6' => Self::Six,
            '5' => Self::Five,
            '4' => Self::Four,
            '3' => Self::Three,
            '2' => Self::Two,
            _ => panic!("Invalid card!"),
        }
    }
}

#[derive(Debug, PartialEq, PartialOrd)]
enum Hand {
    FiveOfAKind(Vec<Card>),
    FourOfAKind(Vec<Card>),
    FullHouse(Vec<Card>),
    ThreeOfAKind(Vec<Card>),
    TwoPair(Vec<Card>),
    OnePair(Vec<Card>),
    HighCard(Vec<Card>),
}

impl Hand {
    fn from(cards: String) -> Self {
        let counts: Vec<u32> = cards
            .chars()
            .fold(HashMap::new(), |mut acc, c| {
                *acc.entry(c).or_insert(0) += 1;
                acc
            })
            .iter()
            .map(|(_, count)| count.to_string().parse::<u32>().unwrap())
            .collect();

        let hand: Vec<Card> = cards.chars().map(|c| Card::from(c)).collect();

        match counts.len() {
            1 => Self::FiveOfAKind(hand),
            2 => match counts.contains(&4) {
                true => Self::FourOfAKind(hand),
                false => Self::FullHouse(hand),
            },
            3 => match counts.contains(&3) {
                true => Self::ThreeOfAKind(hand),
                false => Self::TwoPair(hand),
            },
            4 => Self::OnePair(hand),
            5 => Self::HighCard(hand),
            _ => panic!("Invalid hand!"),
        }
    }

    fn cards(&self) -> &Vec<Card> {
        match &self {
            Self::FiveOfAKind(cards) => cards,
            Self::FourOfAKind(cards) => cards,
            Self::FullHouse(cards) => cards,
            Self::ThreeOfAKind(cards) => cards,
            Self::TwoPair(cards) => cards,
            Self::OnePair(cards) => cards,
            Self::HighCard(cards) => cards,
            _ => panic!("Invalid hand!"),
        }
    }
}

#[derive(Debug)]
struct HandSet {
    hands: Vec<(Hand, u32)>,
}

impl HandSet {
    fn from(input: &str) -> Self {
        let mut hands: Vec<(Hand, u32)> = input
            .lines()
            .map(|line| line.split(" ").collect::<Vec<&str>>())
            .map(|pair| {
                let cards = Hand::from(pair[0].to_string());
                let bid = pair[1].parse::<u32>().unwrap();

                (cards, bid)
            })
            .collect::<Vec<(Hand, u32)>>();

        println!("Hands before sort: {:?}\n", hands);
        hands.sort_by(|h1, h2| {
            h2.0.partial_cmp(&h1.0).unwrap().then_with(|| {
                let cards1 = h1.0.cards();
                let cards2 = h2.0.cards();

                for (c1, c2) in cards1.iter().zip(cards2.iter()) {
                    if c1 > c2 {
                        // return Ordering::Greater;
                    } else if c1 < c2 {
                        // return Ordering::Less;
                    }
                }

                Ordering::Greater
            })
        });
        println!("Hands after sort: {:?}\n", hands);

        // hands.sort_by(|h1, h2| {
        //     h2.0.partial_cmp(&h1.0)
        //         .unwrap()
        //         .then_with(|| h2.1.cmp(&h1.1))
        // });

        Self { hands }
    }
}

// -------------------------------------------------------
// Helper Functions
// -------------------------------------------------------

// fn card_value(card: char) -> usize {
//     CARDS.iter().position(|c| *c == card).unwrap()
// }

// -------------------------------------------------------
// Main program logic
// -------------------------------------------------------

#[allow(dead_code)]
fn pt1(input: &str) -> u32 {
    let hands = HandSet::from(input);
    // println!("Hands: {:?}", hands);

    0

    // hand_set
    //     .hands
    //     .iter()
    //     .enumerate()
    //     .map(|(rank, (_, _, bid))| <usize as TryInto<u32>>::try_into(rank).unwrap() * *bid)
    //     .sum()
}

#[allow(dead_code)]
fn pt2(_input: &str) -> u32 {
    0
}

pub fn day07() {
    let input = read_input("./src/day07/puzzle_input.txt");
    println!("Day 7:");
    println!("Part 1: {}", pt1(&input));
    println!("Part 2: {}", pt2(&input));
    println!("-------------------------------------------------------")
}

// -------------------------------------------------------
// Tests
// -------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pt1() {
        let puzzle_input = "\
32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483\
        ";

        // assert_eq!(pt1(puzzle_input), 6440);
    }

    #[test]
    fn test_pt1_ordering() {
        let puzzle_input = "\
88878 220
87888 684
88788 28
78888 765
88887 483\
";

        assert_eq!(pt1(puzzle_input), 6440);
    }

    #[test]
    fn test_pt2() {
        let _puzzle_input = "\
\
";

        // assert_eq!(pt2(puzzle_input), 71503);
    }
}
